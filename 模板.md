## 1 杂类

### 1.1 常用库函数

#### 1.1.1 上下取整

```c++
 /**   上取整下取整   **/
long long ceilDiv(long long n,long long m) 
{
    if (n >= 0) 
        return (n + m - 1) / m;
    else 
        return n / m;
}
long long floorDiv(long long n,long long m) 
{
    if (n >= 0) 
        return n / m;
    else 
        return (n - m + 1) / m;
}
```

#### 1.1.2 GCD

```c++
long long gcd(long long a, long long b) 
{
    return b ? gcd(b, a % b) : a;
}
```

#### 1.1.3 精确开平方

```c++
long long sqrt(long long n) 
{
    long long s = sqrt(n);
    while (s * s > n) 
    {
        s--;
    }
    while ((s + 1) * (s + 1) <= n) 
    {
        s++;
    }
    return s;
}
```

#### 1.1.4 求log

```c++
int logi(int a, int b) 
{
    int t = 0;
    long long v = 1;
    while (v < b) 
    {
        v *= a;
        t++;
    }
    return t;
}
```

### 1.2 int128

```c++
typedef __int128_t int128;

int128 read(){
    int128 x=0;bool f=0;char c=getchar();
    while (c<'0'||c>'9'){if (c=='-')f=1;c=getchar();}
    while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return f?-x:x;
}

inline void write(int128 x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

int main(){
    int128 a = read();
    int128 b = read();
    write(a*b);
}
```

### 1.3 关闭同步流

```
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```



## 2 基础算法

### 2.1 二分

#### 2.1.1 前驱（最大找最小）

```c++
while (l<=r)
{
    mid = l+r>>1;
    if (check(mid))
    {
        ans = mid;
        r = mid - 1;
    }
    else l = mid + 1;
}
cout<<ans;
```

#### 2.1.2 后继（最小找最大）

```c++
while (l<=r)
{
     mid = l+r>>1;
    if (check(mid))
    {
        l = mid + 1;
        ans = mid;
    }
    else 
    	r=  mid - 1;
}
cout<<ans;
```

### 2.2 前缀和、差分

#### 2.2.1 一维前缀和、差分

```c++
const int N = 1e6;
int chafen[N];
int a[N];
//int pre[N];
void insert(int l,int r,int k)
{
    chafen[l]+=k;
    chafen[r+1]-=k;
}
int main ()
{
    int n ;
    cin>>n;
    for(int i =1;i <= n;i++)
    {
        cin>>a[i];
        //pre[N] +=a[i];
        insert(i,i,a[i]);
    }
    for(int i =1;i <= n;i++)
    {
        chafen[i]+=chafen[i-1];
        cout<<chafen[i]<<" ";
    }
}

```

#### 2.2.2 二维前缀和、差分

```
#include <bits/stdc++.h>

using namespace std;
int  D[1003][1003];

int main ()
{
    int n,m;
    cin>>n>>m;
    for(int i= 1; i <= m;i++)
    {
        int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        D[x1][y1]++;
        D[x1][y2+1]--;
        D[x2+1][y1]--;
        D[x2+1][y2+1]++;
    }
    for(int i =1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            D[i][j] = D[i][j]+ D[i-1][j]+D[i][j-1]-D[i-1][j-1];
            cout<<D[i][j]<<' ';
            //a[i][j] = D[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];
        }

        cout<<endl;
    }
}
```

## 3 数论

### 3.1 快速幂

```c
/**   快速幂 - 普通版   **/
long long power(long long a, long long b, long long p) 
{
    long long res = 1;
    for (; b; b /= 2, a = 1LL * a * a % p) 
    {
        if (b % 2) 
        {
            res = 1LL * res * a % p;
        }
    }
    return res;
}
/**   快速幂 - 手写乘法   **/
long long mul(long long a, long long b, long long p) 
{
	long long c = a * b - (long long)(1.0L * a * b / p) * p;
	c %= p;
    if (c < 0)
    {
        c += p;
    }
    return c;
}
long long power(long long a, long long b, long long p) 
{
    long long res = 1;
    for (; b; b /= 2, a = mul(a, a, p)) 
    {
        if (b % 2) 
        {
            res = mul(res, a, p);
        }
    }
    return res;
}

```

### 3.2 基姆拉尔森公式

```
const int d[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
bool isLeap(int y) {
    return y % 400 == 0 || (y % 4 == 0 && y % 100 != 0);
}
int daysInMonth(int y, int m) {
    return d[m - 1] + (isLeap(y) && m == 2);
}
int getDay(int y, int m, int d) {
    int ans = 0;
    for (int i = 1970; i < y; i++) {
        ans += 365 + isLeap(i);
    }
    for (int i = 1; i < m; i++) {
        ans += daysInMonth(y, i);
    }
    ans += d;
    return (ans + 2) % 7 + 1;
}
```

### 3.3 欧拉筛

其中minp记录最小质因数，primes记录素数。

```c++
vector<int> minp, primes;
void sieve(int n) {
    minp.assign(n + 1, 0);
    primes.clear();

    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            primes.push_back(i);
        }

        for (auto p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                break;
            }
        }
    }
}
bool isprime(int n) {
    return minp[n] == n;
}
```

### 3.4 欧拉函数

设 $n$ 是一个正整数，欧拉函数 $\phi(n)$ 定义为不超过 $n$ 且与 $n$ 互素的正整数的个数。
$$
\phi(n) = \sum\limits_{i=1}^{n}[gcd(i,n) = 1]
$$
**定理1**: 设 $p$ 和 $q$ 是互素的正整数，那么$\phi(pq)=\phi(p)\phi(q)$。

**定理2** 设 $n$ 为正整数，那么
$$
n = \sum\limits_{d|n}\phi(d)
$$
例: 当 $n=12$，有$n=\phi(1)+\phi(2)+\phi(3)+\phi(4)+\phi(6)+\phi(12)$。

**欧拉定理** : 设$m$是一个正整数，$a$是一个整数且$a$与$m$互素，即$gcd(a,m) = 1$，则有$a^{\phi(m)} \equiv 1(\bmod m)$。

#### 3.4.1求解单个数的欧拉函数值

```c++
int phi(int n) {
    int res = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0) {
                n /= i;
            }
            res = res / i * (i - 1);
        }
    }
    if (n > 1) {
        res = res / n * (n - 1);
    }
    return res;
}
```

#### 3.4.2 求解全部数的欧拉函数

其中minp记录最小质因数，primes记录素数，phi记录欧拉函数，后进行求前缀和。

```c++
void sieve(int n) {
    minp.assign(n + 1, 0);
    phi.assign(n + 1, 0);
    primes.clear();

    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            phi[i] = i - 1;
            primes.push_back(i);
        }

        for (auto p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                phi[i * p] = phi[i] * p;
                break;
            }
            phi[i * p] = phi[i] * (p - 1);
        }
    }
    //前缀和
    for (int i = 2; i <= n; i++) {
        phi[i] += phi[i - 1];
    }
}
```



## 4 数据结构

### 4.1并查集



## 5 字符串

### 5.1 BKDRHash

```c++
ull BKDRHash(string x)
{
    ull P = 131,H = 0;
    for(int i = 0;i < x.size();i++)
    {
        H = H * P + x[i];
    }
    return H;
}
```

$S_1+S_2 = H(S_1)*P^{len(S_2)}+H(S_2)$

求前缀：$H(ab)=H(a)*P+H(b),H(abc)=H(ab)*P+H(c)$。

```c++
for(int i  = 1;i <= s.size();i++)
{
	H[i] = H[i-1]*p+s[i-1];
}
```

查询任意子串，$H(de) = H(abcde)-H(abc) * P^2$

求区间$[L,R]$的哈希值

```c++
ull get_hash(ull L,ull R)
{
	return H[R] - H[L - 1] * P[R-L+1];
}
```



## 6 图论

拓扑排序

判环：无入度为0的节点

### 6.1	最短路

#### 6.1.1 Ford

是用来求任意两个结点之间的最短路的。

复杂度比较高，但是常数小，容易实现（只有三个 `for`）。

适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）

```

```



#### 6.1.2 Dijkstra

是一种求解 **非负权图** 上单源最短路径的算法。

$O(n^2+m)$

```c++
#include <bits/stdc++.h>

using namespace std;
#define endl '\n'
const int N = 10003;
struct Z
{
    int v;
    int w;
};
vector<Z> g[N];

int dis[N];
bool vis[N];
const int INF = INT_MAX;
int n,m,s;
void Dijkstra()
{
    for(int i = 1;i <= n;i++)
    {
        dis[i] = INF;
    }
    dis[s] = 0;
    dis[0] = INF;
    while(1)
    {
        int u = 0;
        for(int i = 1;i <= n;i++)
        {
            if(!vis[i]&&dis[u] > dis[i])
            {
                u = i;
            }
        }
        if(u ==0)
            break;
        vis[u] = 1;
        for(int i = 0;i < g[u].size();i++)
        {
            if(dis[g[u][i].v] > dis[u]+g[u][i].w)
            {
                dis[g[u][i].v] = dis[u] + g[u][i].w;
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>s;
    for(int i = 0;i < m;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        g[u].push_back({v,w});
    }
    Dijkstra();
    for(int i = 1;i <= n;i++)
    {
        cout<<dis[i]<<" ";
    }
}
```

堆优化

$O(mlogm)$

如果$m$同级与$n^2$,则不如普通版本。

```c++
#include <bits/stdc++.h>

using namespace std;
#define endl '\n'
struct Z
{
    int v;
    int w;
    friend bool operator < (Z a, Z b)
    {
        return a.w > b.w;
    }
};

vector<Z> g[10003];
priority_queue<Z> q;
int dis[10003];
bool vis[10003];
const int INF = INT_MAX;
int n,m,s;
void Dijkstra()
{
    for(int i = 1;i <= n;i++)
    {
        dis[i] = INF;
    }
    dis[s] = 0;
    dis[0] = INF;
    q.push({s,0});
    while(!q.empty())
    {
        int u = q.top().v;
        q.pop();
        if(vis[u])
            continue;
        vis[u] = 1;
        for(int i = 0;i < g[u].size();i++)
        {
            if(dis[g[u][i].v] > dis[u]+g[u][i].w)
            {
                dis[g[u][i].v] = dis[u] + g[u][i].w;
                q.push({g[u][i].v,dis[g[u][i].v]});
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>s;
    for(int i = 0;i < m;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        g[u].push_back({v,w});
    }
    Dijkstra();
    for(int i = 1;i <= n;i++)
    {
        cout<<dis[i]<<" ";
    }
}
```

